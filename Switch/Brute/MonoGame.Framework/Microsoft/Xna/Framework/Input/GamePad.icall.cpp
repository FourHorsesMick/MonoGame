// GENERATED BY BRUTE
// Microsoft.Xna.Framework.Input.GamePad

#include <mscorlib/1nternal/Brute.h>

#include "MonoGame.Framework/Microsoft/Xna/Framework/Input/GamePad.h"
#include "mscorlib/System/Exception.h"

#include "MonoGame.Framework/Microsoft/Xna/Framework/Input/Buttons.h"
#include "MonoGame.Framework/Microsoft/Xna/Framework/Input/NpadConnectionType.h"

#include <nn/hid/hid_ControllerSupport.h>
#include <nn/hid/hid_Npad.h>
#include <nn/hid/hid_NpadJoy.h>
#include <nn/hid/hid_Vibration.h>

nn::hid::NpadIdType g_NpadIds[] =
{
	nn::hid::NpadId::No1,
	nn::hid::NpadId::Handheld,
};

nn::hid::NpadStyleSet g_NpadStyles[9];

const int NpadIdCount = sizeof(g_NpadIds) / sizeof(g_NpadIds[0]);
const int NpadIdHandheldIndex = sizeof(g_NpadIds) / sizeof(g_NpadIds[0]) - 1;

nn::hid::VibrationDeviceHandle g_VibrationDevices[16] = { 0 };

namespace Microsoft { namespace Xna { namespace Framework { namespace Input { 


void GamePad$_$S_NpadInitialize()
{
	nn::hid::InitializeNpad();
	nn::hid::SetSupportedNpadIdType(g_NpadIds, NpadIdCount);
	nn::hid::SetNpadJoyHoldType(nn::hid::NpadJoyHoldType_Horizontal);
	nn::hid::SetSupportedNpadStyleSet(
		nn::hid::NpadStyleFullKey::Mask
		| nn::hid::NpadStyleJoyDual::Mask
		| nn::hid::NpadStyleHandheld::Mask
		| nn::hid::NpadStyleJoyLeft::Mask
		| nn::hid::NpadStyleJoyRight::Mask);
}

bool GamePad$_$S_NpadIsConnected(int index)
{
	auto style = nn::hid::GetNpadStyleSet(g_NpadIds[index]);
	auto isConnected = style.IsAnyOn();

	if(!isConnected && index == 0)
	{
		return GamePad$_$S_NpadIsConnected(NpadIdHandheldIndex);
	}

	return isConnected;
}

NpadConnectionType GamePad$_$S_NpadGetConnectionType(int index)
{
	auto style = nn::hid::GetNpadStyleSet(g_NpadIds[index]);

	if (style.Test<nn::hid::NpadStyleHandheld>()
	|| style.Test<nn::hid::NpadStyleFullKey>()
	|| style.Test<nn::hid::NpadStyleJoyDual>())
	{
		return NpadConnectionType::DualJoyCon;
	}
	else if (style.Test<nn::hid::NpadStyleJoyLeft>())
	{
		return NpadConnectionType::LeftJoyCon;
	}
	else if (style.Test<nn::hid::NpadStyleJoyRight>())
	{
		return NpadConnectionType::RightJoyCon;
	}
	else if(index == 0)
	{
		return GamePad$_$S_NpadGetConnectionType(NpadIdHandheldIndex);
	}

	return NpadConnectionType::Unknown;
}

static void ToRectangular(float* x, float* y)
{
	double len = sqrt((*x * *x) + (*y * *y));
	if (len > 0.0001)
	{
		// This magic value came from testing the 
		// thumbsticks on several different XB1 
		// controllers on XNA and on MonoGame.
		const double maxLen = 1.28;

		double angle = atan2(*y, *x);
		*x = (len * maxLen) * cos(angle);
		*y = (len * maxLen) * sin(angle);

		if (*x < -1)
			*x = -1;
		if (*x > 1)
			*x = 1;
		if (*y < -1)
			*y = -1;
		if (*y > 1)
			*y = 1;
	}
}

static void NpadGetStateDualMode(nn::hid::NpadButtonSet& buttons, nn::hid::AnalogStickState& analogStickL, nn::hid::AnalogStickState& analogStickR, unsigned int* btns, float* lx, float* ly, float* rx, float* ry, float* lt, float* rt)
{
	auto ButtonA = GamePad::SwapAB ? Buttons::B : Buttons::A;
	auto ButtonB = GamePad::SwapAB ? Buttons::A : Buttons::B;

	*btns = 0;
	*btns |= buttons.Test<nn::hid::NpadButton::Up>() ? Buttons::DPadUp : 0;
	*btns |= buttons.Test<nn::hid::NpadButton::Down>() ? Buttons::DPadDown : 0;
	*btns |= buttons.Test<nn::hid::NpadButton::Left>() ? Buttons::DPadLeft : 0;
	*btns |= buttons.Test<nn::hid::NpadButton::Right>() ? Buttons::DPadRight : 0;
	*btns |= buttons.Test<nn::hid::NpadButton::B>() ? ButtonA : 0;
	*btns |= buttons.Test<nn::hid::NpadButton::A>() ? ButtonB : 0;
	*btns |= buttons.Test<nn::hid::NpadButton::Y>() ? Buttons::X : 0;
	*btns |= buttons.Test<nn::hid::NpadButton::X>() ? Buttons::Y : 0;
	*btns |= buttons.Test<nn::hid::NpadButton::L>() ? Buttons::LeftShoulder : 0;
	*btns |= buttons.Test<nn::hid::NpadButton::R>() ? Buttons::RightShoulder : 0;
	*btns |= buttons.Test<nn::hid::NpadButton::Plus>() ? Buttons::Start : 0;
	*btns |= buttons.Test<nn::hid::NpadButton::Minus>() ? Buttons::Back : 0;
	*btns |= buttons.Test<nn::hid::NpadButton::StickL>() ? Buttons::LeftStick : 0;
	*btns |= buttons.Test<nn::hid::NpadButton::StickR>() ? Buttons::RightStick : 0;
	*btns |= buttons.Test<nn::hid::NpadButton::ZL>() ? Buttons::LeftTrigger : 0;
	*btns |= buttons.Test<nn::hid::NpadButton::ZR>() ? Buttons::RightTrigger : 0;


	*lx = (float)analogStickL.x / (float)nn::hid::AnalogStickMax;
	*ly = (float)analogStickL.y / (float)nn::hid::AnalogStickMax;
	ToRectangular(lx, ly);

	*rx = (float)analogStickR.x / (float)nn::hid::AnalogStickMax;
	*ry = (float)analogStickR.y / (float)nn::hid::AnalogStickMax;
	ToRectangular(rx, ry);

	*lt = buttons.Test<nn::hid::NpadButton::ZL>() ? 1.0f : 0.0f;
	*rt = buttons.Test<nn::hid::NpadButton::ZR>() ? 1.0f : 0.0f;
}

bool GamePad$_$S_NpadGetState(int index, unsigned long long* timestamp, unsigned int* btns, float* lx, float* ly, float* rx, float* ry, float* lt, float* rt)
{
	// Terrible place to insert this, but...
	if (index == 0)
	{
		if (!GamePad$_$S_NpadIsConnected(0) && !GamePad$_$S_NpadIsConnected(1))
		{
			nn::hid::ControllerSupportArg supportArgs;
			supportArgs.SetDefault();
			supportArgs.enablePermitJoyDual = true;
			supportArgs.enableSingleMode = true;
			nn::hid::ShowControllerSupport(supportArgs);
		}
	}
	auto id = g_NpadIds[index];
RETRY:
	auto style = nn::hid::GetNpadStyleSet(id);

	nn::hid::NpadButtonSet buttons;
	nn::hid::AnalogStickState analogStickL;
	nn::hid::AnalogStickState analogStickR;
	nn::hid::NpadAttributesSet attributes;

	auto isConnected = false;

	if (style.Test<nn::hid::NpadStyleHandheld>())
	{
		nn::hid::NpadHandheldState state = {};
		nn::hid::GetNpadState(&state, id);
		*timestamp = state.samplingNumber;
		buttons = state.buttons;
		analogStickL = state.analogStickL;
		analogStickR = state.analogStickR;
		attributes = state.attributes;
		isConnected = true;

		if (isConnected)
		{
			NpadGetStateDualMode(buttons, analogStickL, analogStickR, btns, lx, ly, rx, ry, lt, rt);
		}
	}
	else if (style.Test<nn::hid::NpadStyleJoyDual>())
	{
		nn::hid::NpadJoyDualState state = {};
		nn::hid::GetNpadState(&state, id);
		*timestamp = state.samplingNumber;
		buttons = state.buttons;
		analogStickL = state.analogStickL;
		analogStickR = state.analogStickR;
		attributes = state.attributes;
		isConnected = attributes.Test<nn::hid::NpadAttribute::IsConnected>();

		if (isConnected)
		{
			NpadGetStateDualMode(buttons, analogStickL, analogStickR, btns, lx, ly, rx, ry, lt, rt);
		}
	}
	else if (style.Test<nn::hid::NpadStyleFullKey>())
	{
		nn::hid::NpadFullKeyState state = {};
		nn::hid::GetNpadState(&state, id);
		*timestamp = state.samplingNumber;
		buttons = state.buttons;
		analogStickL = state.analogStickL;
		analogStickR = state.analogStickR;
		attributes = state.attributes;
		isConnected = attributes.Test<nn::hid::NpadAttribute::IsConnected>();
		if (isConnected)
		{
			NpadGetStateDualMode(buttons, analogStickL, analogStickR, btns, lx, ly, rx, ry, lt, rt);
		}
	}
	else if (style.Test<nn::hid::NpadStyleJoyLeft>())
	{
		nn::hid::NpadJoyLeftState state = {};
		nn::hid::GetNpadState(&state, id);
		*timestamp = state.samplingNumber;
		buttons = state.buttons;
		analogStickL = state.analogStickL;
		analogStickR = state.analogStickR;
		attributes = state.attributes;
		isConnected = attributes.Test<nn::hid::NpadAttribute::IsConnected>();
		if (isConnected)
		{
			auto ButtonA = GamePad::SwapAB ? Buttons::B : Buttons::A;
			auto ButtonB = GamePad::SwapAB ? Buttons::A : Buttons::B;

			*btns = 0;
			*btns |= buttons.Test<nn::hid::NpadButton::Left>() ? ButtonA : 0;
			*btns |= buttons.Test<nn::hid::NpadButton::Down>() ? ButtonB : 0;
			*btns |= buttons.Test<nn::hid::NpadButton::Right>() ? Buttons::Y : 0;
			*btns |= buttons.Test<nn::hid::NpadButton::Up>() ? Buttons::X : 0;
			*btns |= buttons.Test<nn::hid::NpadJoyButton::LeftSL>() ? Buttons::LeftShoulder : 0;
			*btns |= buttons.Test<nn::hid::NpadJoyButton::LeftSR>() ? Buttons::RightShoulder : 0;
			*btns |= buttons.Test<nn::hid::NpadButton::Minus>() ? Buttons::Start : 0;
			*btns |= buttons.Test<nn::hid::NpadButton::StickL>() ? Buttons::LeftStick : 0;
			*btns |= buttons.Test<nn::hid::NpadButton::L>() ? Buttons::LeftTrigger : 0;
			*btns |= buttons.Test<nn::hid::NpadButton::ZL>() ? Buttons::RightTrigger : 0;

			*lx = -(float)analogStickL.y / (float)nn::hid::AnalogStickMax;
			*ly = (float)analogStickL.x / (float)nn::hid::AnalogStickMax;
			ToRectangular(lx, ly);
			*rx = 0;
			*ry = 0;

			*lt = buttons.Test<nn::hid::NpadButton::L>() ? 1.0f : 0.0f;
			*rt = buttons.Test<nn::hid::NpadButton::ZL>() ? 1.0f : 0.0f;
		}
	}
	else if (style.Test<nn::hid::NpadStyleJoyRight>())
	{
		nn::hid::NpadJoyRightState state = {};
		nn::hid::GetNpadState(&state, id);
		*timestamp = state.samplingNumber;
		buttons = state.buttons;
		analogStickL = state.analogStickL;
		analogStickR = state.analogStickR;
		attributes = state.attributes;
		isConnected = attributes.Test<nn::hid::NpadAttribute::IsConnected>();
		if (isConnected)
		{
			auto ButtonA = GamePad::SwapAB ? Buttons::B : Buttons::A;
			auto ButtonB = GamePad::SwapAB ? Buttons::A : Buttons::B;

			*btns = 0;
			*btns |= buttons.Test<nn::hid::NpadButton::A>() ? ButtonA : 0;
			*btns |= buttons.Test<nn::hid::NpadButton::X>() ? ButtonB : 0;
			*btns |= buttons.Test<nn::hid::NpadButton::B>() ? Buttons::X : 0;
			*btns |= buttons.Test<nn::hid::NpadButton::Y>() ? Buttons::Y : 0;
			*btns |= buttons.Test<nn::hid::NpadJoyButton::RightSL>() ? Buttons::LeftShoulder : 0;
			*btns |= buttons.Test<nn::hid::NpadJoyButton::RightSR>() ? Buttons::RightShoulder : 0;
			*btns |= buttons.Test<nn::hid::NpadButton::Plus>() ? Buttons::Start : 0;
			*btns |= buttons.Test<nn::hid::NpadButton::StickR>() ? Buttons::LeftStick : 0;
			*btns |= buttons.Test<nn::hid::NpadButton::R>() ? Buttons::LeftTrigger : 0;
			*btns |= buttons.Test<nn::hid::NpadButton::ZR>() ? Buttons::RightTrigger : 0;

			*lx = (float)analogStickR.y / (float)nn::hid::AnalogStickMax;
			*ly = -(float)analogStickR.x / (float)nn::hid::AnalogStickMax;
			ToRectangular(lx, ly);
			*rx = 0;
			*ry = 0;

			*lt = buttons.Test<nn::hid::NpadButton::R>() ? 1.0f : 0.0f;
			*rt = buttons.Test<nn::hid::NpadButton::ZR>() ? 1.0f : 0.0f;
		}
	}
	else if (index == 0 && id != nn::hid::NpadId::Handheld)
	{
		id = nn::hid::NpadId::Handheld;
		goto RETRY;
	}

	if (!isConnected)
	{
		*btns = 0;
		*lx = 0;
		*ly = 0;
		*rx = 0;
		*ry = 0;
		*lt = 0;
		*rt = 0;
	}

	return isConnected;
}

bool GamePad$_$S_NpadSetVibration(int index, float leftMotor, float rightMotor)
{
	auto id = g_NpadIds[index];

RETRY:

	auto style = nn::hid::GetNpadStyleSet(id);

	// If the style is unset then assume handheld mode.
	if (index == 0 && style.IsAllOff())
	{
		id = nn::hid::NpadId::Handheld;
		goto RETRY;
	}

	// If the style changes we need to re-initialize the vibration.
	if (g_NpadStyles[index] != style)
		g_VibrationDevices[index * 2]._storage = 0;

	// Re-initialize the vibration.
	if (g_VibrationDevices[index*2]._storage == 0)
	{		
		nn::hid::GetVibrationDeviceHandles(g_VibrationDevices + index * 2, 2, id, style);
		nn::hid::InitializeVibrationDevice(g_VibrationDevices[index * 2 + 0]);
		nn::hid::InitializeVibrationDevice(g_VibrationDevices[index * 2 + 1]);
		g_NpadStyles[index] = style;
	}

	nn::hid::VibrationDeviceInfo info;

	auto leftVibe = nn::hid::VibrationValue::Make(leftMotor, 130.0f, 0, 180.0f);
	auto rightVibe = nn::hid::VibrationValue::Make(rightMotor, 240.0f, 0, 280.0f);
	for (int i = 0; i < 2; i++)
	{
		auto device = g_VibrationDevices[(index * 2) + i];
		if (device._storage == 0)
			continue;

		nn::hid::GetVibrationDeviceInfo(&info, device);

		if (info.position == nn::hid::VibrationDevicePosition_Left)
			nn::hid::SendVibrationValue(device, leftVibe);
		else if (info.position == nn::hid::VibrationDevicePosition_Right)
			nn::hid::SendVibrationValue(device, rightVibe);
	}

	return true;
}

}}}} // namespace Microsoft.Xna.Framework.Input

